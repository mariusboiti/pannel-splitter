import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import { SVGInfo, Settings, GridInfo, TileInfo } from '../../types';
import { getBaseFileName } from './parser';
import { generateAssemblyMapSVG } from './assemblyMap';

interface ExportOptions {
  svgInfo: SVGInfo;
  settings: Settings;
  gridInfo: GridInfo;
  tiles: TileInfo[];
}

export function generateReadme(options: ExportOptions): string {
  const { svgInfo, settings, gridInfo, tiles } = options;
  const nonEmptyTiles = tiles.filter(t => !t.isEmpty);
  const unsafeTiles = tiles.filter(t => t.hasUnsafeFallback);

  const lines = [
    '========================================',
    'Panel Splitter - Export Summary',
    '========================================',
    '',
    'INPUT DESIGN',
    `  File: ${svgInfo.fileName}`,
    `  Size: ${svgInfo.detectedWidthMm.toFixed(2)} x ${svgInfo.detectedHeightMm.toFixed(2)} mm`,
    '',
    'BED SETTINGS',
    `  Bed Size: ${settings.bedWidth} x ${settings.bedHeight} mm`,
    `  Margin: ${settings.margin} mm`,
    `  Overlap: ${settings.overlap} mm`,
    `  Export Mode: ${settings.exportMode === 'laser-safe' ? 'Laser-Safe Trim' : 'Fast Clip'}`,
    '',
    'GRID LAYOUT',
    `  Rows: ${gridInfo.rows}`,
    `  Columns: ${gridInfo.cols}`,
    `  Total Tiles: ${tiles.length}`,
    `  Non-Empty Tiles: ${nonEmptyTiles.length}`,
    `  Effective Tile Area: ${gridInfo.effectiveTileWidth.toFixed(2)} x ${gridInfo.effectiveTileHeight.toFixed(2)} mm`,
    '',
    'NUMBERING',
    `  Format: ${settings.numberingFormat}`,
    `  Enabled: ${settings.numberingEnabled ? 'Yes' : 'No'}`,
    '',
    'TILE LIST',
  ];

  for (const tile of tiles) {
    const status = tile.isEmpty ? ' (EMPTY)' : tile.hasUnsafeFallback ? ' (UNSAFE FALLBACK)' : '';
    lines.push(`  ${tile.label}: Row ${tile.row + 1}, Col ${tile.col + 1}${status}`);
  }

  if (unsafeTiles.length > 0) {
    lines.push('');
    lines.push('⚠️  WARNING: UNSAFE FALLBACK TILES');
    lines.push('The following tiles contain geometry that could not be properly trimmed.');
    lines.push('Boolean operations failed, so the original shapes were included without clipping.');
    lines.push('Please verify these tiles manually in your laser software:');
    for (const tile of unsafeTiles) {
      lines.push(`  - ${tile.label}`);
    }
  }

  if (settings.exportMode === 'fast-clip') {
    lines.push('');
    lines.push('⚠️  WARNING: FAST CLIP MODE');
    lines.push('Tiles were exported using clipPath, not real geometry trimming.');
    lines.push('Some laser software (e.g., older LightBurn versions) may ignore clip paths.');
    lines.push('If you see artifacts, re-export using Laser-Safe Trim mode.');
  }

  if (settings.registrationMarks.enabled) {
    lines.push('');
    lines.push('REGISTRATION MARKS');
    lines.push(`  Type: ${settings.registrationMarks.type}`);
    lines.push(`  Placement: ${settings.registrationMarks.placement}`);
    lines.push(`  Size: ${settings.registrationMarks.size} mm`);
    lines.push(`  Stroke Width: ${settings.registrationMarks.strokeWidth} mm`);
    if (settings.registrationMarks.type === 'pinhole') {
      lines.push(`  Hole Diameter: ${settings.registrationMarks.holeDiameter} mm`);
    }
  }

  lines.push('');
  lines.push('ASSEMBLY TIPS');
  lines.push('1. Start with tile R01C01 (top-left corner)');
  lines.push('2. Work left-to-right, then top-to-bottom');
  lines.push('3. If overlap is set, align overlapping edges carefully');
  lines.push('4. Use registration marks if guides were enabled');
  lines.push('');
  lines.push('Generated by Panel Splitter - LaserFilesPro');
  lines.push(`Date: ${new Date().toISOString()}`);

  return lines.join('\n');
}

export async function exportToZip(
  options: ExportOptions,
  onProgress?: (current: number, total: number) => void
): Promise<void> {
  const { svgInfo, settings, gridInfo, tiles } = options;
  const baseName = getBaseFileName(svgInfo.fileName);
  const nonEmptyTiles = tiles.filter(t => !t.isEmpty && t.svgContent);

  const zip = new JSZip();
  const hasAssemblyMap = settings.assemblyMap.enabled;
  const total = nonEmptyTiles.length + 1 + (hasAssemblyMap ? 1 : 0);

  for (let i = 0; i < nonEmptyTiles.length; i++) {
    const tile = nonEmptyTiles[i];
    const fileName = `${baseName}_${tile.label}.svg`;
    zip.file(fileName, tile.svgContent!);
    onProgress?.(i + 1, total);
  }

  const readme = generateReadme(options);
  zip.file('README.txt', readme);

  if (hasAssemblyMap) {
    const assemblyMap = generateAssemblyMapSVG(svgInfo, settings, gridInfo, tiles);
    zip.file('assembly_map.svg', assemblyMap);
  }

  onProgress?.(total, total);

  const blob = await zip.generateAsync({ type: 'blob' });
  saveAs(blob, `${baseName}_tiles.zip`);
}
